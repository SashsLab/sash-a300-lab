<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: common/drivers/nandflash.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c5ab7d5005c5f96afef39cd6ff9e2484.html">common</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_640347b79a58de25a4e6f9b018e8e1be.html">drivers</a>
  </div>
</div>
<div class="contents">
<h1>nandflash.c</h1><a href="nandflash_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************/</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;em_device.h&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;em_dma.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;em_ebi.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="dmactrl_8h.html" title="DMA control data block.">dmactrl.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="nandflash_8h.html" title="EFM32GG_STK3700 nandflash driver.">nandflash.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">/**************************************************************************/</span>
<a name="l00060"></a>00060 <span class="comment">/* Define how NAND flash control signals is connected to the EFM32GG. */</span>
<a name="l00061"></a>00061 <span class="preprocessor">#define NAND_POWER_PORT         1</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define NAND_POWER_PIN          (1 &lt;&lt; 15)</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#define NAND_READY_PORT         3</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define NAND_READY_PIN          (1 &lt;&lt; 15)</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CE_PORT            3</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CE_PIN             (1 &lt;&lt; 14)</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define NAND_WP_PORT            3</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define NAND_WP_PIN             (1 &lt;&lt; 13)</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define NAND_ALE_BIT            24</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CLE_BIT            25</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="comment">/* Values secifically for Numonyx NAND256W3A. */</span>
<a name="l00073"></a>00073 <span class="preprocessor">#define NAND256W3A_SIGNATURE    0x7520</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define NAND256W3A_SIZE         (32 * 1024 * 1024)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define NAND256W3A_PAGESIZE     512</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define NAND256W3A_BLOCKSIZE    (16 * 1024)</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="comment">/* Generic NAND flash definitions. */</span>
<a name="l00079"></a>00079 <span class="preprocessor">#define NAND_PAGEADDR_MASK      (NAND256W3A_PAGESIZE - 1)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#define NAND_BLOCKADDR_MASK     (NAND256W3A_BLOCKSIZE - 1)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="preprocessor">#define NAND_RDA_CMD            0x00</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDB_CMD            0x01</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDC_CMD            0x50</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDSIGN_CMD         0x90</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDSTATUS_CMD       0x70</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#define NAND_PAGEPROG1_CMD      0x80</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#define NAND_PAGEPROG2_CMD      0x10</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CPBPROG1_CMD       0x00</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CPBPROG2_CMD       0x8A</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CPBPROG3_CMD       0x10</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#define NAND_BLOCKERASE1_CMD    0x60</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#define NAND_BLOCKERASE2_CMD    0xD0</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RST_CMD            0xFF</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span>
<a name="l00096"></a>00096 <span class="preprocessor">#define NAND_STATUS_SR7         0x80</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define NAND_STATUS_SR6         0x40</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#define NAND_STATUS_SR0         0x01</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>
<a name="l00100"></a>00100 <span class="comment">/* NAND access macros. */</span>
<a name="l00101"></a>00101 <span class="preprocessor">#define NAND_DATA8              *pNandData8</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#define NAND_DATA16             *pNandData16</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#define NAND_DATA32             *pNandData32</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define NAND_ADDR               *pNandAddr</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CMD                *pNandCmd</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span>
<a name="l00107"></a>00107 <span class="comment">/* DMA configuration structures. */</span>
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keyword">const</span> DMA_Init_TypeDef dmaInit =
<a name="l00109"></a>00109 {
<a name="l00110"></a>00110   .hprot        = 0,
<a name="l00111"></a>00111   .controlBlock = <a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>
<a name="l00112"></a>00112 };
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="keyword">static</span> <span class="keyword">const</span> DMA_CfgChannel_TypeDef chnCfg =
<a name="l00115"></a>00115 {
<a name="l00116"></a>00116   .highPri   = <span class="keyword">false</span>,     <span class="comment">/* Default priority */</span>
<a name="l00117"></a>00117   .enableInt = <span class="keyword">false</span>,     <span class="comment">/* No interrupt on transfer completion */</span>
<a name="l00118"></a>00118   .select    = 0,         <span class="comment">/* Memory-memory transfers */</span>
<a name="l00119"></a>00119   .cb        = NULL       <span class="comment">/* No transfer completion callback */</span>
<a name="l00120"></a>00120 };
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keyword">const</span> DMA_CfgDescr_TypeDef descCfgWr =
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124   .dstInc  = dmaDataIncNone,
<a name="l00125"></a>00125   .srcInc  = dmaDataInc4,
<a name="l00126"></a>00126   .size    = dmaDataSize4,
<a name="l00127"></a>00127   .arbRate = dmaArbitrate1,
<a name="l00128"></a>00128   .hprot   = 0
<a name="l00129"></a>00129 };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keyword">static</span> <span class="keyword">const</span> DMA_CfgDescr_TypeDef descCfgRd =
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133   .dstInc  = dmaDataInc4,
<a name="l00134"></a>00134   .srcInc  = dmaDataIncNone,
<a name="l00135"></a>00135   .size    = dmaDataSize4,
<a name="l00136"></a>00136   .arbRate = dmaArbitrate1,
<a name="l00137"></a>00137   .hprot   = 0
<a name="l00138"></a>00138 };
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">/* Private variables. */</span>
<a name="l00141"></a>00141 <span class="keyword">static</span> <a class="code" href="structNANDFLASH__Info__TypeDef.html" title="NANDFLASH device information structure.">NANDFLASH_Info_TypeDef</a> flashInfo;
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">bool</span>                   flashInitialized = <span class="keyword">false</span>;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">static</span> uint8_t <span class="keyword">volatile</span>       *pNandData8;
<a name="l00145"></a>00145 <span class="keyword">static</span> uint16_t <span class="keyword">volatile</span>      *pNandData16;
<a name="l00146"></a>00146 <span class="keyword">static</span> uint32_t <span class="keyword">volatile</span>      *pNandData32;
<a name="l00147"></a>00147 <span class="keyword">static</span> uint8_t <span class="keyword">volatile</span>       *pNandAddr;
<a name="l00148"></a>00148 <span class="keyword">static</span> uint8_t <span class="keyword">volatile</span>       *pNandCmd;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">/* Private function prototypes. */</span>
<a name="l00151"></a>00151 __STATIC_INLINE <span class="keywordtype">void</span>      chipEnable(<span class="keywordtype">bool</span> enable);
<a name="l00152"></a>00152 <span class="keyword">static</span> <span class="keywordtype">int</span>       flashInterrogate(<span class="keywordtype">void</span>);
<a name="l00153"></a>00153 __STATIC_INLINE <span class="keywordtype">void</span>      powerEnable(<span class="keywordtype">bool</span> enable);
<a name="l00154"></a>00154 <span class="keyword">static</span> uint16_t  readSignature(<span class="keywordtype">void</span>);
<a name="l00155"></a>00155 <span class="keyword">static</span> uint8_t   readStatus(<span class="keywordtype">void</span>);
<a name="l00156"></a>00156 <span class="keyword">static</span> <span class="keywordtype">void</span>      reset(<span class="keywordtype">void</span>);
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keywordtype">void</span>      dmaRead(uint8_t *dst, <span class="keywordtype">int</span> count);
<a name="l00158"></a>00158 <span class="keyword">static</span> <span class="keywordtype">void</span>      dmaWrite(uint8_t *src, <span class="keywordtype">int</span> count);
<a name="l00159"></a>00159 __STATIC_INLINE <span class="keywordtype">void</span>      waitReady(<span class="keywordtype">void</span>);
<a name="l00160"></a>00160 __STATIC_INLINE <span class="keywordtype">void</span>      writeProtect(<span class="keywordtype">bool</span> enable);
<a name="l00161"></a>00161 
<a name="l00164"></a>00164 <span class="comment">/***************************************************************************/</span>
<a name="l00174"></a><a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907">00174</a> <span class="keywordtype">bool</span> <a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(uint32_t address)
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176   <span class="keywordflow">if</span> (flashInitialized)
<a name="l00177"></a>00177   {
<a name="l00178"></a>00178     <span class="keywordflow">if</span> ((address &gt;= flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a>) &amp;&amp;
<a name="l00179"></a>00179         (address &lt; (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a> + flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a50ce1667eeb1d371798ed0fff1a82b5c" title="Total device size in bytes.">deviceSize</a>)))
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183   }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="comment">/***************************************************************************/</span>
<a name="l00206"></a><a class="code" href="group__NandFlash.html#ga89e673d7489781772b09cd59fae7f434">00206</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga89e673d7489781772b09cd59fae7f434" title="Copy a page within the device to a new location.">NANDFLASH_CopyPage</a>(uint32_t dstAddr, uint32_t srcAddr)
<a name="l00207"></a>00207 {
<a name="l00208"></a>00208   <span class="keywordtype">int</span> status;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00211"></a>00211   {
<a name="l00212"></a>00212     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00213"></a>00213     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00214"></a>00214   }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   dstAddr &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00217"></a>00217   srcAddr &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(dstAddr) ||
<a name="l00220"></a>00220       !<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(srcAddr) ||
<a name="l00221"></a>00221       <span class="comment">/* Address bit 24 must be equal for source and destination page. */</span>
<a name="l00222"></a>00222       ((dstAddr &amp; (1 &lt;&lt; 24)) != (srcAddr &amp; (1 &lt;&lt; 24))))
<a name="l00223"></a>00223   {
<a name="l00224"></a>00224     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00225"></a>00225     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00226"></a>00226   }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   writeProtect(<span class="keyword">false</span>);
<a name="l00229"></a>00229   chipEnable(<span class="keyword">true</span>);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   NAND_CMD  = NAND_CPBPROG1_CMD;
<a name="l00232"></a>00232   NAND_ADDR = (uint8_t) srcAddr;
<a name="l00233"></a>00233   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00234"></a>00234   NAND_ADDR = (uint8_t)(srcAddr &gt;&gt; 9);
<a name="l00235"></a>00235   NAND_ADDR = (uint8_t)(srcAddr &gt;&gt; 17);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   waitReady();
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   NAND_CMD  = NAND_CPBPROG2_CMD;
<a name="l00240"></a>00240   NAND_ADDR = (uint8_t) dstAddr;
<a name="l00241"></a>00241   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00242"></a>00242   NAND_ADDR = (uint8_t)(dstAddr &gt;&gt; 9);
<a name="l00243"></a>00243   NAND_ADDR = (uint8_t)(dstAddr &gt;&gt; 17);
<a name="l00244"></a>00244   NAND_CMD  = NAND_CPBPROG3_CMD;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246   waitReady();
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   status = (readStatus() &amp; NAND_STATUS_SR0) ?
<a name="l00249"></a>00249            <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ae747e446bff895ff1c9fe46e1db04c67" title="Nand flash write error, block is &amp;quot;bad&amp;quot;.">NANDFLASH_WRITE_ERROR</a> : <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   chipEnable(<span class="keyword">false</span>);
<a name="l00252"></a>00252   writeProtect(<span class="keyword">true</span>);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   <span class="keywordflow">return</span> status;
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="comment">/***************************************************************************/</span>
<a name="l00266"></a><a class="code" href="group__NandFlash.html#ga29aff61f11d96570357f048c5599f103">00266</a> <a class="code" href="structNANDFLASH__Info__TypeDef.html" title="NANDFLASH device information structure.">NANDFLASH_Info_TypeDef</a> *<a class="code" href="group__NandFlash.html#ga29aff61f11d96570357f048c5599f103" title="Return a pointer to a NANDFLASH_Info_TypeDef structure, which contain vital nand...">NANDFLASH_DeviceInfo</a>(<span class="keywordtype">void</span>)
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268   <span class="keywordflow">if</span> (flashInitialized)
<a name="l00269"></a>00269   {
<a name="l00270"></a>00270     <span class="keywordflow">return</span> &amp;flashInfo;
<a name="l00271"></a>00271   }
<a name="l00272"></a>00272   <span class="keywordflow">return</span> NULL;
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">/***************************************************************************/</span>
<a name="l00293"></a><a class="code" href="group__NandFlash.html#ga5f05f548912d09981e531480b6802700">00293</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga5f05f548912d09981e531480b6802700" title="Check generated ECC against ECC read from device and correct data if possible.">NANDFLASH_EccCorrect</a>(uint32_t generatedEcc, uint32_t readEcc, uint8_t *data)
<a name="l00294"></a>00294 {
<a name="l00296"></a>00296 <span class="preprocessor">  #define ECC_MASK24    0x00FFFFFF          </span><span class="comment">/* 24 valid ECC parity bits. */</span>
<a name="l00297"></a>00297 <span class="preprocessor">  #define ECC_MASK      0x00555555          </span><span class="comment">/* 12 ECC parity bits.       */</span>
<a name="l00298"></a>00298 
<a name="l00300"></a>00300   <span class="keywordtype">int</span>      count, bitNum, byteAddr;
<a name="l00301"></a>00301   uint32_t mask;
<a name="l00302"></a>00302   uint32_t syndrome;
<a name="l00303"></a>00303   uint32_t eccP;                            <span class="comment">/* 12 even ECC parity bits. */</span>
<a name="l00304"></a>00304   uint32_t eccPn;                           <span class="comment">/* 12 odd ECC parity bits.  */</span>
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   syndrome = (generatedEcc ^ readEcc) &amp; ECC_MASK24;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">if</span> (syndrome == 0)
<a name="l00309"></a>00309     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;             <span class="comment">/* No errors in data. */</span>
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   eccPn = syndrome &amp; ECC_MASK;              <span class="comment">/* Get twelve odd parity bits.  */</span>
<a name="l00312"></a>00312   eccP  = (syndrome &gt;&gt; 1) &amp; ECC_MASK;       <span class="comment">/* Get twelve even parity bits. */</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="keywordflow">if</span> ((eccPn ^ eccP) == ECC_MASK)           <span class="comment">/* 1-bit correctable error ? */</span>
<a name="l00315"></a>00315   {
<a name="l00316"></a>00316     bitNum = (eccP &amp; 0x01) |
<a name="l00317"></a>00317              ((eccP &gt;&gt; 1) &amp; 0x02) |
<a name="l00318"></a>00318              ((eccP &gt;&gt; 2) &amp; 0x04);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     byteAddr = ((eccP &gt;&gt; 6) &amp; 0x001) |
<a name="l00321"></a>00321                ((eccP &gt;&gt; 7) &amp; 0x002) |
<a name="l00322"></a>00322                ((eccP &gt;&gt; 8) &amp; 0x004) |
<a name="l00323"></a>00323                ((eccP &gt;&gt; 9) &amp; 0x008) |
<a name="l00324"></a>00324                ((eccP &gt;&gt; 10) &amp; 0x010) |
<a name="l00325"></a>00325                ((eccP &gt;&gt; 11) &amp; 0x020) |
<a name="l00326"></a>00326                ((eccP &gt;&gt; 12) &amp; 0x040) |
<a name="l00327"></a>00327                ((eccP &gt;&gt; 13) &amp; 0x080) |
<a name="l00328"></a>00328                ((eccP &gt;&gt; 14) &amp; 0x100);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     data[ byteAddr ] ^= 1 &lt;&lt; bitNum;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="comment">/* Count number of one&#39;s in the syndrome. */</span>
<a name="l00336"></a>00336   count = 0;
<a name="l00337"></a>00337   mask  = 0x00800000;
<a name="l00338"></a>00338   <span class="keywordflow">while</span> (mask)
<a name="l00339"></a>00339   {
<a name="l00340"></a>00340     <span class="keywordflow">if</span> (syndrome &amp; mask)
<a name="l00341"></a>00341       count++;
<a name="l00342"></a>00342     mask &gt;&gt;= 1;
<a name="l00343"></a>00343   }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keywordflow">if</span> (count == 1)                           <span class="comment">/* Error in the ECC itself. */</span>
<a name="l00346"></a>00346     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a015251afa4ae85548ba1239c4825d699" title="Illegal ECC value read from spare area.">NANDFLASH_ECC_ERROR</a>;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773af5863d48609dca796592be1a067e080f" title="Uncorrectable data error in page.">NANDFLASH_ECC_UNCORRECTABLE</a>;       <span class="comment">/* Unable to correct data. */</span>
<a name="l00349"></a>00349 
<a name="l00351"></a>00351 <span class="preprocessor">  #undef ECC_MASK</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span><span class="preprocessor">  #undef ECC_MASK24</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span>
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">/***************************************************************************/</span>
<a name="l00371"></a><a class="code" href="group__NandFlash.html#gab6b041fc25f751a48aea91db3409f094">00371</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#gab6b041fc25f751a48aea91db3409f094" title="Erase a block in the nand flash.">NANDFLASH_EraseBlock</a>(uint32_t address)
<a name="l00372"></a>00372 {
<a name="l00373"></a>00373   <span class="keywordtype">int</span> status;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00376"></a>00376   {
<a name="l00377"></a>00377     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00378"></a>00378     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00379"></a>00379   }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   address &amp;= ~NAND_BLOCKADDR_MASK;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00384"></a>00384   {
<a name="l00385"></a>00385     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00386"></a>00386     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   writeProtect(<span class="keyword">false</span>);
<a name="l00390"></a>00390   chipEnable(<span class="keyword">true</span>);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   NAND_CMD = NAND_BLOCKERASE1_CMD;
<a name="l00393"></a>00393   <span class="comment">/* Coloumn address, bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00394"></a>00394   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00395"></a>00395   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00396"></a>00396   NAND_CMD  = NAND_BLOCKERASE2_CMD;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398   waitReady();
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   status = (readStatus() &amp; NAND_STATUS_SR0) ?
<a name="l00401"></a>00401            <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ae747e446bff895ff1c9fe46e1db04c67" title="Nand flash write error, block is &amp;quot;bad&amp;quot;.">NANDFLASH_WRITE_ERROR</a> : <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   chipEnable(<span class="keyword">false</span>);
<a name="l00404"></a>00404   writeProtect(<span class="keyword">true</span>);
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keywordflow">return</span> status;
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="comment">/***************************************************************************/</span>
<a name="l00425"></a><a class="code" href="group__NandFlash.html#ga77237e34d1ad7e9ea927c64f77ec6e24">00425</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga77237e34d1ad7e9ea927c64f77ec6e24" title="Initialize the NANDFLASH module.">NANDFLASH_Init</a>(<span class="keywordtype">int</span> dmaCh)
<a name="l00426"></a>00426 {
<a name="l00427"></a>00427   <span class="keywordflow">if</span> ((dmaCh &lt; -1) || (dmaCh &gt;= DMA_CHAN_COUNT))
<a name="l00428"></a>00428   {
<a name="l00429"></a>00429     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00430"></a>00430     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a504fbafcb79cd7d9fc26007e6e3e6772" title="Invalid parameter to NANDFLASH_Init().">NANDFLASH_INVALID_SETUP</a>;
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> = dmaCh;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <span class="keywordflow">if</span> (dmaCh &gt;= 0)
<a name="l00436"></a>00436   {
<a name="l00437"></a>00437     DMA_Init((<span class="keywordtype">void</span>*) &amp;dmaInit);              <span class="comment">/* Initialize the DMA */</span>
<a name="l00438"></a>00438     DMA_CfgChannel(dmaCh, (<span class="keywordtype">void</span>*) &amp;chnCfg);  <span class="comment">/* Configure the DMA channel */</span>
<a name="l00439"></a>00439   }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="keywordflow">return</span> flashInterrogate();
<a name="l00442"></a>00442 }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment">/***************************************************************************/</span>
<a name="l00460"></a><a class="code" href="group__NandFlash.html#gac4148bf559466d233cccf815adbeb95d">00460</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#gac4148bf559466d233cccf815adbeb95d" title="Mark a block as bad.">NANDFLASH_MarkBadBlock</a>(uint32_t address)
<a name="l00461"></a>00461 {
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00463"></a>00463   {
<a name="l00464"></a>00464     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00465"></a>00465     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00466"></a>00466   }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   address &amp;= ~NAND_BLOCKADDR_MASK;
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00471"></a>00471   {
<a name="l00472"></a>00472     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00473"></a>00473     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00474"></a>00474   }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   writeProtect(<span class="keyword">false</span>);
<a name="l00477"></a>00477   chipEnable(<span class="keyword">true</span>);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   NAND_CMD  = NAND_RDC_CMD;
<a name="l00480"></a>00480   NAND_CMD  = NAND_PAGEPROG1_CMD;
<a name="l00481"></a>00481   NAND_ADDR = (uint8_t) address;
<a name="l00482"></a>00482   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDC_CMD. */</span>
<a name="l00483"></a>00483   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00484"></a>00484   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="comment">/* Write bad block marker 0x00 to the 6th byte in the spare area */</span>
<a name="l00487"></a>00487   NAND_DATA32 = 0xFFFFFFFF;
<a name="l00488"></a>00488   NAND_DATA16 = 0x00FF;
<a name="l00489"></a>00489   NAND_CMD    = NAND_PAGEPROG2_CMD;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   waitReady();
<a name="l00492"></a>00492   readStatus();
<a name="l00493"></a>00493 
<a name="l00494"></a>00494   chipEnable(<span class="keyword">false</span>);
<a name="l00495"></a>00495   writeProtect(<span class="keyword">true</span>);
<a name="l00496"></a>00496 
<a name="l00497"></a>00497   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="comment">/***************************************************************************/</span>
<a name="l00518"></a><a class="code" href="group__NandFlash.html#gac7c2bddd174fa07c8140b38c7584cc59">00518</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#gac7c2bddd174fa07c8140b38c7584cc59" title="Read a page from nand device.">NANDFLASH_ReadPage</a>(uint32_t address, uint8_t *buffer)
<a name="l00519"></a>00519 {
<a name="l00520"></a>00520   uint32_t i, readEcc, *p;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00523"></a>00523   {
<a name="l00524"></a>00524     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00525"></a>00525     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00526"></a>00526   }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   address &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00531"></a>00531   {
<a name="l00532"></a>00532     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00533"></a>00533     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00534"></a>00534   }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   chipEnable(<span class="keyword">true</span>);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   NAND_CMD  = NAND_RDA_CMD;
<a name="l00539"></a>00539   NAND_ADDR = (uint8_t) address;
<a name="l00540"></a>00540   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00541"></a>00541   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00542"></a>00542   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00543"></a>00543 
<a name="l00544"></a>00544   waitReady();
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   EBI_StartNandEccGen();
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00549"></a>00549   {
<a name="l00550"></a>00550     p = (uint32_t*) buffer;
<a name="l00551"></a>00551     <span class="keywordflow">for</span> (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a> / 4; i++)
<a name="l00552"></a>00552     {
<a name="l00553"></a>00553       *p++ = NAND_DATA32;
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555   }
<a name="l00556"></a>00556   <span class="keywordflow">else</span>
<a name="l00557"></a>00557   {
<a name="l00558"></a>00558     dmaRead(buffer, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a>);
<a name="l00559"></a>00559   }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> = EBI_StopNandEccGen();
<a name="l00562"></a>00562 
<a name="l00563"></a>00563   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00564"></a>00564   {
<a name="l00565"></a>00565     p = (uint32_t*) flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>;
<a name="l00566"></a>00566     for (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a> / 4; i++)
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568       *p++ = NAND_DATA32;
<a name="l00569"></a>00569     }
<a name="l00570"></a>00570   }
<a name="l00571"></a>00571   <span class="keywordflow">else</span>
<a name="l00572"></a>00572   {
<a name="l00573"></a>00573     dmaRead(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a>);
<a name="l00574"></a>00574   }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   chipEnable(<span class="keyword">false</span>);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   readEcc  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>[ <a class="code" href="group__NandFlash.html#ga68202c2af9400be750e866347c1ae77e" title="Spare area position of ECC byte 0 (LSB).">NAND_SPARE_ECC0_POS</a> ];
<a name="l00579"></a>00579   readEcc += flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>[ <a class="code" href="group__NandFlash.html#ga291ef2093c6334b58316c7eb96359cec" title="Spare area position of ECC byte 1.">NAND_SPARE_ECC1_POS</a> ] &lt;&lt; 8;
<a name="l00580"></a>00580   readEcc += flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>[ <a class="code" href="group__NandFlash.html#ga0acc344f59146337478dd4099f7bef7c" title="Spare area position of ECC byte 2 (MSB).">NAND_SPARE_ECC2_POS</a> ] &lt;&lt; 16;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#ga5f05f548912d09981e531480b6802700" title="Check generated ECC against ECC read from device and correct data if possible.">NANDFLASH_EccCorrect</a>(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a>, readEcc, buffer);
<a name="l00583"></a>00583 }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="comment">/***************************************************************************/</span>
<a name="l00599"></a><a class="code" href="group__NandFlash.html#ga9a52019a2c065536e1c707aea6f27830">00599</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga9a52019a2c065536e1c707aea6f27830" title="Read the spare area content of a page.">NANDFLASH_ReadSpare</a>(uint32_t address, uint8_t *buffer)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601   uint32_t i, *p;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00604"></a>00604   {
<a name="l00605"></a>00605     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00606"></a>00606     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00607"></a>00607   }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   address &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00612"></a>00612   {
<a name="l00613"></a>00613     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00614"></a>00614     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00615"></a>00615   }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   chipEnable(<span class="keyword">true</span>);
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   NAND_CMD  = NAND_RDC_CMD;
<a name="l00620"></a>00620   NAND_ADDR = (uint8_t) address;
<a name="l00621"></a>00621   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDC_CMD. */</span>
<a name="l00622"></a>00622   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00623"></a>00623   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625   waitReady();
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00628"></a>00628   {
<a name="l00629"></a>00629     p = (uint32_t*) buffer;
<a name="l00630"></a>00630     <span class="keywordflow">for</span> (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a> / 4; i++)
<a name="l00631"></a>00631     {
<a name="l00632"></a>00632       *p++ = NAND_DATA32;
<a name="l00633"></a>00633     }
<a name="l00634"></a>00634   }
<a name="l00635"></a>00635   <span class="keywordflow">else</span>
<a name="l00636"></a>00636   {
<a name="l00637"></a>00637     dmaRead(buffer, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a>);
<a name="l00638"></a>00638   }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   chipEnable(<span class="keyword">false</span>);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00643"></a>00643 }
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">/***************************************************************************/</span>
<a name="l00664"></a><a class="code" href="group__NandFlash.html#ga1414ac5f995f6e37bef82297ff2f51a5">00664</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga1414ac5f995f6e37bef82297ff2f51a5" title="Write a page in nand device.">NANDFLASH_WritePage</a>(uint32_t address, uint8_t *buffer)
<a name="l00665"></a>00665 {
<a name="l00666"></a>00666   <span class="keywordtype">int</span>      status;
<a name="l00667"></a>00667   uint32_t i, *p;
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00670"></a>00670   {
<a name="l00671"></a>00671     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00672"></a>00672     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00673"></a>00673   }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   address &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00678"></a>00678   {
<a name="l00679"></a>00679     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00680"></a>00680     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00681"></a>00681   }
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   writeProtect(<span class="keyword">false</span>);
<a name="l00684"></a>00684   chipEnable(<span class="keyword">true</span>);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   NAND_CMD  = NAND_RDA_CMD;
<a name="l00687"></a>00687   NAND_CMD  = NAND_PAGEPROG1_CMD;
<a name="l00688"></a>00688   NAND_ADDR = (uint8_t) address;
<a name="l00689"></a>00689   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00690"></a>00690   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00691"></a>00691   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="comment">/* Wait for EBI idle in case of EBI writeBuffer is enabled */</span>
<a name="l00694"></a>00694   <span class="keywordflow">while</span> (EBI-&gt;STATUS &amp; EBI_STATUS_AHBACT)
<a name="l00695"></a>00695   {
<a name="l00696"></a>00696   }
<a name="l00697"></a>00697   EBI_StartNandEccGen();
<a name="l00698"></a>00698 
<a name="l00699"></a>00699   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00700"></a>00700   {
<a name="l00701"></a>00701     p = (uint32_t*) buffer;
<a name="l00702"></a>00702     <span class="keywordflow">for</span> (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a> / 4; i++)
<a name="l00703"></a>00703     {
<a name="l00704"></a>00704       NAND_DATA32 = *p++;
<a name="l00705"></a>00705     }
<a name="l00706"></a>00706   }
<a name="l00707"></a>00707   <span class="keywordflow">else</span>
<a name="l00708"></a>00708   {
<a name="l00709"></a>00709     dmaWrite(buffer, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a>);
<a name="l00710"></a>00710   }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712   <span class="comment">/* Wait for EBI idle in case of EBI writeBuffer is enabled */</span>
<a name="l00713"></a>00713   <span class="keywordflow">while</span> (EBI-&gt;STATUS &amp; EBI_STATUS_AHBACT)
<a name="l00714"></a>00714   {
<a name="l00715"></a>00715   }
<a name="l00716"></a>00716   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> = EBI_StopNandEccGen();
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="comment">/* Write ECC to spare area */</span>
<a name="l00719"></a>00719   NAND_DATA32 = 0xFFFFFFFF;
<a name="l00720"></a>00720   NAND_DATA16 = 0xFFFF;
<a name="l00721"></a>00721   NAND_DATA8  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a>;
<a name="l00722"></a>00722   NAND_DATA8  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> &gt;&gt; 8;
<a name="l00723"></a>00723   NAND_DATA8  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> &gt;&gt; 16;
<a name="l00724"></a>00724   NAND_CMD    = NAND_PAGEPROG2_CMD;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726   waitReady();
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   status = (readStatus() &amp; NAND_STATUS_SR0) ?
<a name="l00729"></a>00729            <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ae747e446bff895ff1c9fe46e1db04c67" title="Nand flash write error, block is &amp;quot;bad&amp;quot;.">NANDFLASH_WRITE_ERROR</a> : <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   chipEnable(<span class="keyword">false</span>);
<a name="l00732"></a>00732   writeProtect(<span class="keyword">true</span>);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734   <span class="keywordflow">return</span> status;
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 
<a name="l00739"></a>00739 <span class="comment">/***************************************************************************/</span>
<a name="l00742"></a>00742 __STATIC_INLINE <span class="keywordtype">void</span> chipEnable(<span class="keywordtype">bool</span> enable)
<a name="l00743"></a>00743 {
<a name="l00744"></a>00744   <span class="keywordflow">if</span> (enable)
<a name="l00745"></a>00745   {
<a name="l00746"></a>00746     GPIO-&gt;P[NAND_CE_PORT].DOUTCLR = NAND_CE_PIN;
<a name="l00747"></a>00747   }
<a name="l00748"></a>00748   <span class="keywordflow">else</span>
<a name="l00749"></a>00749   {
<a name="l00750"></a>00750     GPIO-&gt;P[NAND_CE_PORT].DOUTSET = NAND_CE_PIN;
<a name="l00751"></a>00751   }
<a name="l00752"></a>00752 }
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="comment">/***************************************************************************/</span>
<a name="l00757"></a>00757 <span class="keyword">static</span> <span class="keywordtype">int</span> flashInterrogate(<span class="keywordtype">void</span>)
<a name="l00758"></a>00758 {
<a name="l00759"></a>00759   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a> = EBI_BankAddress(EBI_BANK0);
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   pNandData8  = (uint8_t <span class="keyword">volatile</span>*) flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a>;
<a name="l00762"></a>00762   pNandData16 = (uint16_t <span class="keyword">volatile</span>*) pNandData8;
<a name="l00763"></a>00763   pNandData32 = (uint32_t <span class="keyword">volatile</span>*) pNandData8;
<a name="l00764"></a>00764   pNandAddr   = pNandData8 + (1 &lt;&lt; NAND_ALE_BIT);
<a name="l00765"></a>00765   pNandCmd    = pNandData8 + (1 &lt;&lt; NAND_CLE_BIT);
<a name="l00766"></a>00766 
<a name="l00767"></a>00767   powerEnable(<span class="keyword">true</span>);
<a name="l00768"></a>00768   waitReady();
<a name="l00769"></a>00769   chipEnable(<span class="keyword">true</span>);
<a name="l00770"></a>00770   reset();
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <span class="keywordflow">if</span> (readSignature() != NAND256W3A_SIGNATURE)
<a name="l00773"></a>00773   {
<a name="l00774"></a>00774     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00775"></a>00775     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6434929fd0044be49277f4b3c5b95d26" title="Invalid (unsupported) flash device.">NANDFLASH_INVALID_DEVICE</a>;
<a name="l00776"></a>00776   }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   chipEnable(<span class="keyword">false</span>);
<a name="l00779"></a>00779 
<a name="l00780"></a>00780   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a86fa0f38e71a4d26d3e5708c50f0e28b" title="The device manufacturer code.">manufacturerCode</a> = (uint8_t) NAND256W3A_SIGNATURE;
<a name="l00781"></a>00781   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a18af4ceede2c81c5139a20e68724b810" title="The device ID .">deviceCode</a>       = (uint8_t)(NAND256W3A_SIGNATURE &gt;&gt; 8);
<a name="l00782"></a>00782   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a50ce1667eeb1d371798ed0fff1a82b5c" title="Total device size in bytes.">deviceSize</a>       = NAND256W3A_SIZE;
<a name="l00783"></a>00783   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a>         = NAND256W3A_PAGESIZE;
<a name="l00784"></a>00784   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a>        = <a class="code" href="group__NandFlash.html#gaa9340348b9962d9ef5c0adec85cf4009" title="Spare area size of Numonyx NAND256W3A.">NAND256W3A_SPARESIZE</a>;
<a name="l00785"></a>00785   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ad61a70b5bebfac7669e503164a0809b6" title="Device block size in bytes.">blockSize</a>        = NAND256W3A_BLOCKSIZE;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   flashInitialized = <span class="keyword">true</span>;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="comment">/***************************************************************************/</span>
<a name="l00795"></a>00795 __STATIC_INLINE <span class="keywordtype">void</span> powerEnable(<span class="keywordtype">bool</span> enable)
<a name="l00796"></a>00796 {
<a name="l00797"></a>00797   <span class="keywordflow">if</span> (enable)
<a name="l00798"></a>00798   {
<a name="l00799"></a>00799     GPIO-&gt;P[NAND_POWER_PORT].DOUTSET = NAND_POWER_PIN;
<a name="l00800"></a>00800   }
<a name="l00801"></a>00801   <span class="keywordflow">else</span>
<a name="l00802"></a>00802   {
<a name="l00803"></a>00803     GPIO-&gt;P[NAND_POWER_PORT].DOUTCLR = NAND_POWER_PIN;
<a name="l00804"></a>00804   }
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="comment">/***************************************************************************/</span>
<a name="l00810"></a>00810 <span class="keyword">static</span> uint16_t readSignature(<span class="keywordtype">void</span>)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812   NAND_CMD = NAND_RDSIGN_CMD;
<a name="l00813"></a>00813   <span class="keywordflow">return</span> NAND_DATA16;
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="comment">/***************************************************************************/</span>
<a name="l00819"></a>00819 <span class="keyword">static</span> uint8_t readStatus(<span class="keywordtype">void</span>)
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821   NAND_CMD = NAND_RDSTATUS_CMD;
<a name="l00822"></a>00822   <span class="keywordflow">return</span> NAND_DATA8;
<a name="l00823"></a>00823 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 <span class="comment">/***************************************************************************/</span>
<a name="l00828"></a>00828 <span class="keyword">static</span> <span class="keywordtype">void</span> reset(<span class="keywordtype">void</span>)
<a name="l00829"></a>00829 {
<a name="l00830"></a>00830   NAND_CMD = NAND_RST_CMD;
<a name="l00831"></a>00831   waitReady();
<a name="l00832"></a>00832 }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 <span class="comment">/***************************************************************************/</span>
<a name="l00837"></a>00837 <span class="keyword">static</span> <span class="keywordtype">void</span> dmaRead(uint8_t *dst, <span class="keywordtype">int</span> count)
<a name="l00838"></a>00838 {
<a name="l00839"></a>00839   DMA_CfgDescr(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, (<span class="keywordtype">void</span>*) &amp;descCfgRd);
<a name="l00840"></a>00840   DMA_ActivateAuto(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, dst, (<span class="keywordtype">void</span>*) pNandData32, (count / 4) - 1);
<a name="l00841"></a>00841   <span class="keywordflow">while</span> ((<a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>[flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>].CTRL &amp; _DMA_CTRL_CYCLE_CTRL_MASK)
<a name="l00842"></a>00842          != DMA_CTRL_CYCLE_CTRL_INVALID)
<a name="l00843"></a>00843   {
<a name="l00844"></a>00844   }
<a name="l00845"></a>00845 }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847 <span class="comment">/***************************************************************************/</span>
<a name="l00850"></a>00850 <span class="keyword">static</span> <span class="keywordtype">void</span> dmaWrite(uint8_t *src, <span class="keywordtype">int</span> count)
<a name="l00851"></a>00851 {
<a name="l00852"></a>00852   DMA_CfgDescr(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, (<span class="keywordtype">void</span>*) &amp;descCfgWr);
<a name="l00853"></a>00853   DMA_ActivateAuto(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, (<span class="keywordtype">void</span>*) pNandData32, src, (count / 4) - 1);
<a name="l00854"></a>00854   <span class="keywordflow">while</span> ((<a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>[flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>].CTRL &amp; _DMA_CTRL_CYCLE_CTRL_MASK)
<a name="l00855"></a>00855          != DMA_CTRL_CYCLE_CTRL_INVALID)
<a name="l00856"></a>00856   {
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="comment">/***************************************************************************/</span>
<a name="l00863"></a>00863 __STATIC_INLINE <span class="keywordtype">void</span> waitReady(<span class="keywordtype">void</span>)
<a name="l00864"></a>00864 {
<a name="l00865"></a>00865   <span class="comment">/* Wait for EBI idle in case of EBI writeBuffer is enabled */</span>
<a name="l00866"></a>00866   <span class="keywordflow">while</span> (EBI-&gt;STATUS &amp; EBI_STATUS_AHBACT)
<a name="l00867"></a>00867   {
<a name="l00868"></a>00868   }
<a name="l00869"></a>00869   <span class="comment">/* Wait on Ready/Busy pin to become high */</span>
<a name="l00870"></a>00870   <span class="keywordflow">while</span> ((GPIO-&gt;P[NAND_READY_PORT].DIN &amp; NAND_READY_PIN) == 0)
<a name="l00871"></a>00871   {
<a name="l00872"></a>00872   }
<a name="l00873"></a>00873 }
<a name="l00874"></a>00874 
<a name="l00875"></a>00875 <span class="comment">/***************************************************************************/</span>
<a name="l00878"></a>00878 __STATIC_INLINE <span class="keywordtype">void</span> writeProtect(<span class="keywordtype">bool</span> enable)
<a name="l00879"></a>00879 {
<a name="l00880"></a>00880   <span class="keywordflow">if</span> (enable)
<a name="l00881"></a>00881   {
<a name="l00882"></a>00882     GPIO-&gt;P[NAND_WP_PORT].DOUTCLR = NAND_WP_PIN;
<a name="l00883"></a>00883   }
<a name="l00884"></a>00884   <span class="keywordflow">else</span>
<a name="l00885"></a>00885   {
<a name="l00886"></a>00886     GPIO-&gt;P[NAND_WP_PORT].DOUTSET = NAND_WP_PIN;
<a name="l00887"></a>00887   }
<a name="l00888"></a>00888 }
<a name="l00889"></a>00889 
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Fri Nov 9 16:47:43 2012</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
