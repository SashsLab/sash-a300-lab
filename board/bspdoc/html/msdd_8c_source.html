<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: common/drivers/msdd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c5ab7d5005c5f96afef39cd6ff9e2484.html">common</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_640347b79a58de25a4e6f9b018e8e1be.html">drivers</a>
  </div>
</div>
<div class="contents">
<h1>msdd.c</h1><a href="msdd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************/</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;em_usb.h&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;em_cmu.h&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;em_gpio.h&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="msdbot_8h.html" title="Definitions for the Bulk Only Transport protocol of USB Mass Storage devices.">msdbot.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="msdscsi_8h.html" title="SCSI interface for Mass Storage Devices (MSD).">msdscsi.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="msdd_8h.html" title="Mass Storage class Device (MSD) driver.">msdd.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;msddmedia.h&quot;</span>
<a name="l00042"></a>00042 
<a name="l00045"></a>00045 <span class="comment">/*** Typedef&#39;s and defines. ***/</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#define BULK_OUT        0x01</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define BULK_IN         0x81</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define DIR_DATA_OUT    0</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#define DIR_DATA_IN     1</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define MAX_BURST       32768U          </span><span class="comment">/* 32 * 1024 */</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/**************************************************************************/</span>
<a name="l00056"></a>00056 <span class="keyword">typedef</span> <span class="keyword">enum</span>
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058   MSDD_IDLE                 = 0,
<a name="l00059"></a>00059   MSDD_WAITFOR_CBW          = 1,
<a name="l00060"></a>00060   MSDD_WAITFOR_RECOVERY     = 2,
<a name="l00061"></a>00061   MSDD_SEND_CSW             = 3,
<a name="l00062"></a>00062   MSDD_WAIT_FOR_INUNSTALLED = 4,
<a name="l00063"></a>00063   MSDD_STALL_IN             = 5,
<a name="l00064"></a>00064   MSDD_ACCESS_INDIRECT      = 6,
<a name="l00065"></a>00065   MSDD_WRITE_INDIRECT       = 7,
<a name="l00066"></a>00066   MSDD_DO_CMD_TASK          = 8,
<a name="l00067"></a>00067 } msdState_TypeDef;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/*** Function prototypes. ***/</span>
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keywordtype">int</span>            CbwCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00072"></a>00072 __STATIC_INLINE <span class="keywordtype">bool</span>  CswMeaningful(<span class="keywordtype">void</span>);
<a name="l00073"></a>00073 __STATIC_INLINE <span class="keywordtype">bool</span>  CswValid(<span class="keywordtype">void</span>);
<a name="l00074"></a>00074 __STATIC_INLINE <span class="keywordtype">void</span>  EnableNextCbw(<span class="keywordtype">void</span>);
<a name="l00075"></a>00075 <span class="keyword">static</span> <span class="keywordtype">void</span>           ProcessScsiCdb(<span class="keywordtype">void</span>);
<a name="l00076"></a>00076 __STATIC_INLINE <span class="keywordtype">void</span>  SendCsw(<span class="keywordtype">void</span>);
<a name="l00077"></a>00077 <span class="keyword">static</span> <span class="keywordtype">int</span>            UsbSetupCmd(<span class="keyword">const</span> USB_Setup_TypeDef *setup);
<a name="l00078"></a>00078 <span class="keyword">static</span> <span class="keywordtype">void</span>           UsbStateChangeEvent(USBD_State_TypeDef oldState, USBD_State_TypeDef newState);
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keywordtype">void</span>           UsbXferBotData(uint8_t *data, uint32_t len, USB_XferCompleteCb_TypeDef cb);
<a name="l00080"></a>00080 <span class="keyword">static</span> <span class="keywordtype">void</span>           XferBotData(uint32_t length);
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keywordtype">int</span>            XferBotDataCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00082"></a>00082 <span class="keyword">static</span> <span class="keywordtype">int</span>            XferBotDataIndirectCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">/*** Include device descriptor definitions. ***/</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="preprocessor">#include &quot;descriptors.h&quot;</span>
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="comment">/*** Variables ***/</span>
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">/* Storage for one CBW */</span>
<a name="l00091"></a>00091 STATIC_UBUF(cbw, USB_MAX_EP_SIZE);
<a name="l00092"></a>00092 <span class="keyword">static</span> <a class="code" href="structMSDBOT__CBW__TypeDef.html" title="Bulk Only Transport (BOT) Command Block Wrapper (CBW) typedef.">MSDBOT_CBW_TypeDef</a> *pCbw = (<a class="code" href="structMSDBOT__CBW__TypeDef.html" title="Bulk Only Transport (BOT) Command Block Wrapper (CBW) typedef.">MSDBOT_CBW_TypeDef</a>*) &amp;cbw;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 EFM32_ALIGN(4)
<a name="l00095"></a>00095 <span class="comment">/* Storage for one CSW */</span>
<a name="l00096"></a>00096 static <a class="code" href="structMSDBOT__CSW__TypeDef.html" title="Bulk Only Transport (BOT) Command Status Wrapper (CSW) typedef.">MSDBOT_CSW_TypeDef</a> csw __attribute__ ((aligned(4)));
<a name="l00097"></a>00097 static <a class="code" href="structMSDBOT__CSW__TypeDef.html" title="Bulk Only Transport (BOT) Command Status Wrapper (CSW) typedef.">MSDBOT_CSW_TypeDef</a> *pCsw = &amp;csw;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 STATIC_UBUF(mediaBuffer, <a class="code" href="group__Msd.html#gae1bda16775ab83b9f08d2196aef40898" title="Intermediate media storage buffer size.">MEDIA_BUFSIZ</a>);  <span class="comment">/* Intermediate media storage buffer */</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 static <a class="code" href="structMSDD__CmdStatus__TypeDef.html" title="Status info for one BOT CBW -&amp;gt; Data I/O -&amp;gt; CSW cycle.">MSDD_CmdStatus_TypeDef</a> CmdStatus;
<a name="l00102"></a>00102 static <a class="code" href="structMSDD__CmdStatus__TypeDef.html" title="Status info for one BOT CBW -&amp;gt; Data I/O -&amp;gt; CSW cycle.">MSDD_CmdStatus_TypeDef</a> *pCmdStatus = &amp;CmdStatus;
<a name="l00103"></a>00103 static msdState_TypeDef       savedState; <span class="comment">/* MSD state machine state. */</span>
<a name="l00104"></a>00104 static <span class="keywordtype">int</span> ledPort;
<a name="l00105"></a>00105 static <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ledPin;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">/**************************************************************************/</span>
<a name="l00110"></a>00110 EFM32_ALIGN(4)
<a name="l00111"></a>00111 static const <a class="code" href="structMSDSCSI__InquiryData__TypeDef.html" title="SCSI Inquiry response data typedef.">MSDSCSI_InquiryData_TypeDef</a> InquiryData __attribute__ ((aligned(4))) =
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113   { .PeripheralDeviceType = 0, .PeripheralQualifier = 0 }, <span class="comment">/* Block device  */</span>
<a name="l00114"></a>00114   { .Reserved1            = 0, .Removable           = 1 },
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   .Version = 5,                                       <span class="comment">/* T10 SPC-3 compliant */</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   { .ResponseDataFormat = 2,                          <span class="comment">/* T10 SPC-3 compliant reponse data */</span>
<a name="l00119"></a>00119     .HiSup              = 0, .NormACA = 0, .Obsolete1 = 0 },
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   .AdditionalLength = 31,
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   { .Protect = 0, .Reserved2           = 0, .ThirdPartyCode = 0,
<a name="l00124"></a>00124     .Tpgs    = 0, .Acc = 0, .Sccs = 0 },
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   { .Addr16 = 0, .Obsolete2           = 0, .MChngr = 0, .MultiP = 0,
<a name="l00127"></a>00127     .Vs1    = 0, .EncServ = 0, .BQue = 0 },
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   { .Vs2  = 0, .CmdQue              =0, .Obsolete3 = 0, .Linked = 0,
<a name="l00130"></a>00130     .Sync = 0, .Wbus16 = 0, .Obsolete4 = 0 },
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   .T10VendorId          = { <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span> },
<a name="l00133"></a>00133   .ProductId            = { <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;e&#39;</span> },
<a name="l00134"></a>00134   .ProductRevisionLevel ={ <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;.&#39;</span>, <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;0&#39;</span> }
<a name="l00135"></a>00135 };
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">/**************************************************************************/</span>
<a name="l00142"></a>00142 EFM32_ALIGN(4)
<a name="l00143"></a>00143 static const <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> NoSenseData __attribute__ ((aligned(4))) =
<a name="l00144"></a>00144 {
<a name="l00145"></a>00145   { .ResponseCode      = 0x70, .Valid    = 0 },
<a name="l00146"></a>00146   .Obsolete = 0,
<a name="l00147"></a>00147   { .SenseKey          =    0, .Reserved =0, .Ili = 0, .Eom = 0, .FileMark = 0 },
<a name="l00148"></a>00148   .Information      = 0,
<a name="l00149"></a>00149   .AdditionalLength = 10,
<a name="l00150"></a>00150   .CmdSpecificInfo  = 0,
<a name="l00151"></a>00151   .Asc              = 0,
<a name="l00152"></a>00152   .Ascq             = 0,
<a name="l00153"></a>00153   .Fruc             = 0,
<a name="l00154"></a>00154   { .SenseKeySpecific1 =    0, .Sksv     = 0 },
<a name="l00155"></a>00155   .SenseKeySpecific2 = 0,
<a name="l00156"></a>00156   .SenseKeySpecific3 = 0
<a name="l00157"></a>00157 };
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="comment">/**************************************************************************/</span>
<a name="l00165"></a>00165 EFM32_ALIGN(4)
<a name="l00166"></a>00166 static const <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> IllegalSenseData __attribute__ ((aligned(4))) =
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168   { .ResponseCode      = 0x70, .Valid = 0 },
<a name="l00169"></a>00169   .Obsolete = 0,
<a name="l00170"></a>00170   { .SenseKey =    5,          <span class="comment">/* SensKey = 5 =&gt; ILLEGAL REQUEST */</span>
<a name="l00171"></a>00171     .Reserved = 0, .Ili = 0, .Eom = 0, .FileMark = 0 },
<a name="l00172"></a>00172   .Information      = 0,
<a name="l00173"></a>00173   .AdditionalLength = 10,
<a name="l00174"></a>00174   .CmdSpecificInfo  = 0,
<a name="l00175"></a>00175   .Asc              = 0x24,    <span class="comment">/* Asc/Ascq = 0x24/0x00 =&gt; INVALID FIELD IN CDB*/</span>
<a name="l00176"></a>00176   .Ascq             = 0,
<a name="l00177"></a>00177   .Fruc             = 0,
<a name="l00178"></a>00178   { .SenseKeySpecific1 =    0, .Sksv  = 0 },
<a name="l00179"></a>00179   .SenseKeySpecific2 = 0,
<a name="l00180"></a>00180   .SenseKeySpecific3 = 0
<a name="l00181"></a>00181 };
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keyword">static</span> <span class="keyword">volatile</span> msdState_TypeDef        msdState;     
<a name="l00184"></a>00184 <span class="keyword">static</span> <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> *pSenseData;  
<a name="l00188"></a>00188 <span class="comment">/**************************************************************************/</span>
<a name="l00198"></a><a class="code" href="group__Msd.html#ga6bab19f6afa0c63c3c735c9bea3b8242">00198</a> <span class="keywordtype">void</span> <a class="code" href="group__Msd.html#ga6bab19f6afa0c63c3c735c9bea3b8242" title="Initialize MSD device.">MSDD_Init</a>(<span class="keywordtype">int</span> activityLedPort, uint32_t activityLedPin)
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200   <span class="keywordflow">if</span> ((<span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>) != <a class="code" href="group__Msd.html#gaeeee5bff632d8292bdf27234a2db1610" title="SCSI Read (10) CBD length.">SCSI_READ10_LEN</a>) ||
<a name="l00201"></a>00201       (<span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>) != <a class="code" href="group__Msd.html#ga412dd9e12c21fbd38201d7b8fb4ac25f" title="SCSI Write (10) CDB length.">SCSI_WRITE10_LEN</a>) ||
<a name="l00202"></a>00202       (<span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>) != <a class="code" href="group__Msd.html#gaabd4aaed3342eaa039c186b217f54340" title="SCSI Request Sense CDB length.">SCSI_REQUESTSENSE_LEN</a>) ||
<a name="l00203"></a>00203       (<span class="keyword">sizeof</span>(InquiryData) != <a class="code" href="group__Msd.html#ga59d92155a959caa17dee09196cf59e7c" title="SCSI Inquiry response data length.">SCSI_INQUIRYDATA_LEN</a>) ||
<a name="l00204"></a>00204       (<span class="keyword">sizeof</span>(NoSenseData) != <a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a>) ||
<a name="l00205"></a>00205       (<span class="keyword">sizeof</span>(IllegalSenseData) != <a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a>) ||
<a name="l00206"></a>00206       (<span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>) != <a class="code" href="group__Msd.html#ga32c98aaaced7b71e7a0271aea8f4d0e4" title="SCSI Read Capacity CDB length.">SCSI_READCAPACITY_LEN</a>) ||
<a name="l00207"></a>00207       (<span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__ReadCapacityData__TypeDef.html" title="SCSI Read Capacity response data typedef.">MSDSCSI_ReadCapacityData_TypeDef</a>) != <a class="code" href="group__Msd.html#gab6ed4755185c4e6d8d0de6f8dd021e8c" title="SCSI Read Capacity response data length.">SCSI_READCAPACITYDATA_LEN</a>))
<a name="l00208"></a>00208   {
<a name="l00209"></a>00209     DEBUG_USB_API_PUTS(<span class="stringliteral">&quot;\nMSDD_Init(), typedef size error&quot;</span>);
<a name="l00210"></a>00210     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00211"></a>00211     <span class="keywordflow">return</span>;
<a name="l00212"></a>00212   }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="keywordflow">if</span> ( ( activityLedPort &gt;= gpioPortA ) &amp;&amp; ( activityLedPort &lt;= gpioPortF ) )
<a name="l00215"></a>00215     ledPort = activityLedPort;
<a name="l00216"></a>00216   <span class="keywordflow">else</span>
<a name="l00217"></a>00217     ledPort = -1;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   ledPin     = activityLedPin;
<a name="l00220"></a>00220   msdState   = MSDD_IDLE;
<a name="l00221"></a>00221   pSenseData = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;NoSenseData;
<a name="l00222"></a>00222   USBD_Init(&amp;initstruct);     <span class="comment">/* Start USB. */</span>
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00225"></a>00225   {
<a name="l00226"></a>00226     CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);
<a name="l00227"></a>00227     GPIO_PinModeSet((GPIO_Port_TypeDef)ledPort, ledPin, gpioModePushPull, 0);
<a name="l00228"></a>00228   }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="comment">/*</span>
<a name="l00231"></a>00231 <span class="comment">   * When using a debugger it is pratical to uncomment the following three</span>
<a name="l00232"></a>00232 <span class="comment">   * lines to force host to re-enumerate the device.</span>
<a name="l00233"></a>00233 <span class="comment">   */</span>
<a name="l00234"></a>00234   <span class="comment">/* USBD_Disconnect(); */</span>
<a name="l00235"></a>00235   <span class="comment">/* USBTIMER_DelayMs( 1000 ); */</span>
<a name="l00236"></a>00236   <span class="comment">/* USBD_Connect(); */</span>
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">/**************************************************************************/</span>
<a name="l00248"></a><a class="code" href="group__Msd.html#ga0dfd9473471d01231de7541cfd7f5ede">00248</a> <span class="keywordtype">bool</span> <a class="code" href="group__Msd.html#ga0dfd9473471d01231de7541cfd7f5ede" title="Serve the MSD state machine.">MSDD_Handler</a>(<span class="keywordtype">void</span>)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250   <span class="keyword">static</span> uint32_t len;        <span class="comment">/* Note: len is static ! */</span>
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="keywordflow">switch</span> (msdState)
<a name="l00253"></a>00253   {
<a name="l00254"></a>00254   <span class="keywordflow">case</span> MSDD_ACCESS_INDIRECT:
<a name="l00255"></a>00255     <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00256"></a>00256     {
<a name="l00257"></a>00257       len = EFM32_MIN(pCmdStatus-&gt;xferLen, pCmdStatus-&gt;maxBurst);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259       msdState = MSDD_IDLE;
<a name="l00260"></a>00260       <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00261"></a>00261       {
<a name="l00262"></a>00262         MSDDMEDIA_Read(pCmdStatus, mediaBuffer, len / 512);
<a name="l00263"></a>00263       }
<a name="l00264"></a>00264       UsbXferBotData(mediaBuffer, len, XferBotDataIndirectCallback);
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266     <span class="keywordflow">else</span>
<a name="l00267"></a>00267     {
<a name="l00268"></a>00268       <span class="comment">/* We are done ! */</span>
<a name="l00269"></a>00269       msdState = savedState;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271       <span class="keywordflow">if</span> (msdState == MSDD_SEND_CSW)
<a name="l00272"></a>00272       {
<a name="l00273"></a>00273         SendCsw();
<a name="l00274"></a>00274         EnableNextCbw();
<a name="l00275"></a>00275         msdState = MSDD_WAITFOR_CBW;
<a name="l00276"></a>00276       }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msdState == MSDD_STALL_IN)
<a name="l00279"></a>00279       {
<a name="l00280"></a>00280         USBD_StallEp(BULK_IN);
<a name="l00281"></a>00281         msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00282"></a>00282       }
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284     <span class="keywordflow">break</span>;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <span class="keywordflow">case</span> MSDD_WRITE_INDIRECT:
<a name="l00287"></a>00287     MSDDMEDIA_Write(pCmdStatus, mediaBuffer, len / 512);
<a name="l00288"></a>00288     pCmdStatus-&gt;lba += len / 512;
<a name="l00289"></a>00289     msdState         = MSDD_ACCESS_INDIRECT;
<a name="l00290"></a>00290     <span class="keywordflow">break</span>;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="keywordflow">case</span> MSDD_DO_CMD_TASK:
<a name="l00293"></a>00293     <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>[ 0 ] == <a class="code" href="group__Msd.html#ga732b33c6fded33c1e25db28a34f38315" title="SCSI Start Stop Unit command opcode.">SCSI_STARTSTOP_UNIT</a>)
<a name="l00294"></a>00294     {
<a name="l00295"></a>00295       MSDDMEDIA_Flush();
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297     <span class="comment">/* else if ( .... )  Add more when needed. */</span>
<a name="l00298"></a>00298     SendCsw();
<a name="l00299"></a>00299     EnableNextCbw();
<a name="l00300"></a>00300     msdState = MSDD_WAITFOR_CBW;
<a name="l00301"></a>00301     <span class="keywordflow">break</span>;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   <span class="keywordflow">default</span>:
<a name="l00304"></a>00304     <span class="keywordflow">break</span>;
<a name="l00305"></a>00305   }
<a name="l00306"></a>00306   <span class="keywordflow">return</span> (msdState == MSDD_WAITFOR_CBW) || (msdState == MSDD_IDLE);
<a name="l00307"></a>00307 }
<a name="l00308"></a>00308 
<a name="l00311"></a>00311 <span class="comment">/**************************************************************************/</span>
<a name="l00328"></a>00328 <span class="keyword">static</span> <span class="keywordtype">int</span> CbwCallback(USB_Status_TypeDef status,
<a name="l00329"></a>00329                        uint32_t xferred, uint32_t remaining)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331   (void) remaining;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="keywordflow">if</span> ((msdState == MSDD_WAITFOR_CBW) &amp;&amp;
<a name="l00334"></a>00334       (status == USB_STATUS_OK) &amp;&amp;
<a name="l00335"></a>00335       (xferred == CBW_LEN) &amp;&amp;
<a name="l00336"></a>00336       (CswValid()) &amp;&amp;
<a name="l00337"></a>00337       (CswMeaningful()))
<a name="l00338"></a>00338   {
<a name="l00339"></a>00339     <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00340"></a>00340       GPIO_PinOutToggle((GPIO_Port_TypeDef)ledPort, ledPin);
<a name="l00341"></a>00341 
<a name="l00342"></a>00342     <span class="comment">/* Check the SCSI command descriptor block (CDB) */</span>
<a name="l00343"></a>00343     ProcessScsiCdb();
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     <span class="keywordflow">if</span> (pCmdStatus-&gt;valid)
<a name="l00346"></a>00346       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDPASSED;
<a name="l00347"></a>00347     <span class="keywordflow">else</span>
<a name="l00348"></a>00348       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDFAILED;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     pCsw-&gt;dCSWSignature   = CSW_SIGNATURE;
<a name="l00351"></a>00351     pCsw-&gt;dCSWTag         = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a51e2064e5f20133e5ce96bb3d79be263" title="The CBW tag.">dCBWTag</a>;
<a name="l00352"></a>00352     pCsw-&gt;dCSWDataResidue = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="comment">/* Check the &quot;thirteen cases&quot; */</span>
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     <span class="keywordflow">if</span> ((pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> != 0) &amp;&amp;
<a name="l00357"></a>00357         (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a> != pCmdStatus-&gt;direction))
<a name="l00358"></a>00358     {
<a name="l00359"></a>00359       <span class="comment">/* Handle cases 8 and 10 */</span>
<a name="l00360"></a>00360       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>)
<a name="l00363"></a>00363       {
<a name="l00364"></a>00364         <span class="comment">/* Host expects to receive data, case 8 */</span>
<a name="l00365"></a>00365         USBD_StallEp(BULK_IN);
<a name="l00366"></a>00366         msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00367"></a>00367       }
<a name="l00368"></a>00368       <span class="keywordflow">else</span>
<a name="l00369"></a>00369       {
<a name="l00370"></a>00370         <span class="comment">/* Host expects to send data, case 10 */</span>
<a name="l00371"></a>00371         USBD_StallEp(BULK_OUT);
<a name="l00372"></a>00372         SendCsw();
<a name="l00373"></a>00373         msdState = MSDD_IDLE;
<a name="l00374"></a>00374       }
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a> || (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == 0))
<a name="l00378"></a>00378     {
<a name="l00379"></a>00379       <span class="comment">/* SCSI IN commands or commands without data phase */</span>
<a name="l00380"></a>00380       <span class="comment">/* Handle cases 1-7 */</span>
<a name="l00381"></a>00381 
<a name="l00382"></a>00382       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == 0)
<a name="l00383"></a>00383       {
<a name="l00384"></a>00384         <span class="comment">/* Host expects no data, case 1, 2 or 3 */</span>
<a name="l00385"></a>00385         <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00386"></a>00386         {
<a name="l00387"></a>00387           <span class="comment">/* Device has data to transmit, case 2 &amp; 3 */</span>
<a name="l00388"></a>00388           pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391         <span class="keywordflow">if</span> ((pCmdStatus-&gt;xferLen == 0) &amp;&amp;
<a name="l00392"></a>00392             (pCmdStatus-&gt;xferType == XFER_INDIRECT))
<a name="l00393"></a>00393         {
<a name="l00394"></a>00394           <span class="comment">/* Commands with no data phase which require timeconsuming  */</span>
<a name="l00395"></a>00395           <span class="comment">/* processing are executed in MSDD_Handler()                */</span>
<a name="l00396"></a>00396           msdState = MSDD_DO_CMD_TASK;
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398         <span class="keywordflow">else</span>
<a name="l00399"></a>00399         {
<a name="l00400"></a>00400           SendCsw();
<a name="l00401"></a>00401           EnableNextCbw();
<a name="l00402"></a>00402           msdState = MSDD_WAITFOR_CBW;
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404       }
<a name="l00405"></a>00405       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == pCmdStatus-&gt;xferLen)
<a name="l00406"></a>00406       {
<a name="l00407"></a>00407         <span class="comment">/* Host and device agree on transferlength, case 6 */</span>
<a name="l00408"></a>00408         <span class="comment">/* Send data to host */</span>
<a name="l00409"></a>00409         msdState = MSDD_SEND_CSW;
<a name="l00410"></a>00410         XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00411"></a>00411       }
<a name="l00412"></a>00412       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> &gt; pCmdStatus-&gt;xferLen)
<a name="l00413"></a>00413       {
<a name="l00414"></a>00414         <span class="comment">/* Host expects more data than device can provide, case 4 and 5 */</span>
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen &gt; 0)
<a name="l00417"></a>00417         {
<a name="l00418"></a>00418           <span class="comment">/* Device has data, case 5 */</span>
<a name="l00419"></a>00419           <span class="comment">/* Send data to host */</span>
<a name="l00420"></a>00420           msdState = MSDD_STALL_IN;
<a name="l00421"></a>00421           XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00422"></a>00422         }
<a name="l00423"></a>00423         <span class="keywordflow">else</span>
<a name="l00424"></a>00424         {
<a name="l00425"></a>00425           <span class="comment">/* Device has no data, case 4 */</span>
<a name="l00426"></a>00426           USBD_StallEp(BULK_IN);
<a name="l00427"></a>00427           msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429       }
<a name="l00430"></a>00430       <span class="keywordflow">else</span>
<a name="l00431"></a>00431       {
<a name="l00432"></a>00432         <span class="comment">/* Host expects less data than device will provide, case 7 */</span>
<a name="l00433"></a>00433         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00434"></a>00434         <span class="comment">/* Send data to host */</span>
<a name="l00435"></a>00435         msdState = MSDD_SEND_CSW;
<a name="l00436"></a>00436         XferBotData(pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>);
<a name="l00437"></a>00437       }
<a name="l00438"></a>00438     }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440     <span class="keywordflow">else</span> <span class="comment">/* Host Direction is OUT and Host transferlength &gt; 0 */</span>
<a name="l00441"></a>00441     {
<a name="l00442"></a>00442       <span class="comment">/* SCSI OUT commands */</span>
<a name="l00443"></a>00443       <span class="comment">/* Handle cases 9, 11, 12 and 13 */</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == pCmdStatus-&gt;xferLen)
<a name="l00446"></a>00446       {
<a name="l00447"></a>00447         <span class="comment">/* Host and device agree on transferlength, case 12 */</span>
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         <span class="comment">/* Read data from host */</span>
<a name="l00450"></a>00450         msdState = MSDD_SEND_CSW;
<a name="l00451"></a>00451         XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> &gt; pCmdStatus-&gt;xferLen)
<a name="l00454"></a>00454       {
<a name="l00455"></a>00455         <span class="comment">/* Host intend to send more data than device expects, case 9 &amp; 11 */</span>
<a name="l00456"></a>00456         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDFAILED;
<a name="l00457"></a>00457         USBD_StallEp(BULK_OUT);
<a name="l00458"></a>00458         SendCsw();
<a name="l00459"></a>00459         msdState = MSDD_IDLE;
<a name="l00460"></a>00460       }
<a name="l00461"></a>00461       <span class="keywordflow">else</span>
<a name="l00462"></a>00462       {
<a name="l00463"></a>00463         <span class="comment">/* Host has less data than device expects to receive, case 13 */</span>
<a name="l00464"></a>00464         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00465"></a>00465         USBD_StallEp(BULK_OUT);
<a name="l00466"></a>00466         SendCsw();
<a name="l00467"></a>00467         msdState = MSDD_IDLE;
<a name="l00468"></a>00468       }
<a name="l00469"></a>00469     }
<a name="l00470"></a>00470     <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00471"></a>00471   }
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="keywordflow">if</span> ((status == USB_STATUS_OK) &amp;&amp;
<a name="l00474"></a>00474       (USBD_GetUsbState() == USBD_STATE_CONFIGURED))
<a name="l00475"></a>00475   {
<a name="l00476"></a>00476     <span class="comment">/* Stall both Ep&#39;s and wait for reset recovery */</span>
<a name="l00477"></a>00477     USBD_StallEp(BULK_OUT);
<a name="l00478"></a>00478     USBD_StallEp(BULK_IN);
<a name="l00479"></a>00479     msdState = MSDD_WAITFOR_RECOVERY;
<a name="l00480"></a>00480   }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="comment">/**************************************************************************/</span>
<a name="l00490"></a>00490 __STATIC_INLINE <span class="keywordtype">bool</span> CswMeaningful(<span class="keywordtype">void</span>)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492   <span class="keywordflow">if</span> ((pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a1abbfdf14047d26d30fe8f66eeb1411e" title="Reserved, expect 0.">Reserved1</a> == 0) &amp;&amp;
<a name="l00493"></a>00493       (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a75f9c429399372fbe1fb70467210db20" title="Obsolete, expect 0.">Obsolete</a> == 0) &amp;&amp;
<a name="l00494"></a>00494       (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#ad93f3797202c31f12d8dda26326b36be" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp;
<a name="l00495"></a>00495       (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#adab4dcae6200ccb3a2a5d0671aba3be5" title="Device Logical Unit Number.">Lun</a> == 0) &amp;&amp;
<a name="l00496"></a>00496       (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a764d1ea8ecdae55613ff3ad79a8f3461" title="Reserved, expect 0.">Reserved3</a> == 0))
<a name="l00497"></a>00497   {
<a name="l00498"></a>00498     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00499"></a>00499   }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">/**************************************************************************/</span>
<a name="l00509"></a>00509 __STATIC_INLINE <span class="keywordtype">bool</span> CswValid(<span class="keywordtype">void</span>)
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   <span class="keywordflow">return</span> pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a713e73e9aba992ba6d97837ba39dec8c" title="The CBW signature (ascii USBC).">dCBWSignature</a> == CBW_SIGNATURE ? <span class="keyword">true</span> : <span class="keyword">false</span>; <span class="comment">/* Ascii USBC */</span>
<a name="l00512"></a>00512 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="comment">/**************************************************************************/</span>
<a name="l00518"></a>00518 __STATIC_INLINE <span class="keywordtype">void</span> EnableNextCbw(<span class="keywordtype">void</span>)
<a name="l00519"></a>00519 {
<a name="l00520"></a>00520   USBD_Read(BULK_OUT, (<span class="keywordtype">void</span>*) &amp;cbw, USB_MAX_EP_SIZE, CbwCallback);
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 <span class="comment">/**************************************************************************/</span>
<a name="l00528"></a>00528 <span class="keyword">static</span> <span class="keywordtype">void</span> ProcessScsiCdb(<span class="keywordtype">void</span>)
<a name="l00529"></a>00529 {
<a name="l00530"></a>00530   <a class="code" href="structMSDSCSI__Inquiry__TypeDef.html" title="SCSI Inquiry Command Descriptor Block (CDB) typedef.">MSDSCSI_Inquiry_TypeDef</a>      *cbI;
<a name="l00531"></a>00531   <a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a> *cbRS;
<a name="l00532"></a>00532   <a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a> *cbRC;
<a name="l00533"></a>00533   <a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>       *cbR10;
<a name="l00534"></a>00534   <a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>      *cbW10;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   EFM32_ALIGN(4)
<a name="l00537"></a>00537   static <a class="code" href="structMSDSCSI__ReadCapacityData__TypeDef.html" title="SCSI Read Capacity response data typedef.">MSDSCSI_ReadCapacityData_TypeDef</a> ReadCapData __attribute__ ((aligned(4)));
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   pCmdStatus-&gt;valid    = false;
<a name="l00540"></a>00540   pCmdStatus-&gt;xferType = XFER_MEMORYMAPPED;
<a name="l00541"></a>00541   pCmdStatus-&gt;maxBurst = MAX_BURST;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543   switch (pCbw-&gt;CBWCB[ 0 ])
<a name="l00544"></a>00544   {
<a name="l00545"></a>00545   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#gab4c8f5b2d1f25d97b00b9df156ccc283" title="SCSI Inquiry command opcode.">SCSI_INQUIRY</a>:
<a name="l00546"></a>00546     cbI = (<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html" title="SCSI Inquiry Command Descriptor Block (CDB) typedef.">MSDSCSI_Inquiry_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     if ((cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#af899eee2e39c656937846058b75ec6c0" title="Enable Vital Product data.">Evpd</a> == 0) &amp;&amp; (cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#a04ada094ef3e0a16ea93876216395476" title="Pagecode.">PageCode</a> == 0))
<a name="l00549"></a>00549     {
<a name="l00550"></a>00550       <span class="comment">/* Standard Inquiry data request */</span>
<a name="l00551"></a>00551       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00552"></a>00552       pCmdStatus-&gt;direction = DIR_DATA_IN;
<a name="l00553"></a>00553       pCmdStatus-&gt;pData     = (uint8_t*) &amp;InquiryData;
<a name="l00554"></a>00554       pCmdStatus-&gt;xferLen   = EFM32_MIN(<a class="code" href="group__Msd.html#ga59d92155a959caa17dee09196cf59e7c" title="SCSI Inquiry response data length.">SCSI_INQUIRYDATA_LEN</a>,
<a name="l00555"></a>00555                                         __REV16(cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#a425c76925763cc8e363882b9a16493e0" title="Number of inquiry data bytes requested.">AllocationLength</a>));
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557     <span class="keywordflow">break</span>;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga10f4287430fb0b3832ef457bd413d709" title="SCSI Request Sense command opcode.">SCSI_REQUESTSENSE</a>:
<a name="l00560"></a>00560     cbRS = (<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     if ((cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#ae2b17b045b6184a08d78553837a90de9" title="Descriptor format.">Desc</a> == 0) &amp;&amp; (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a8bb0ae69d8e75ed18fdb619b465d748f" title="Reserved, expect 0.">Reserved1</a> == 0) &amp;&amp;
<a name="l00563"></a>00563         (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a198e363c27bbe1a92976ff6aca143eb7" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp; (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a6c5abb63ad406f601ca9532c095fe2e5" title="Reserved, expect 0.">Reserved3</a> == 0))
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00566"></a>00566       pCmdStatus-&gt;direction = DIR_DATA_IN;
<a name="l00567"></a>00567       pCmdStatus-&gt;pData     = (uint8_t*) pSenseData;
<a name="l00568"></a>00568       pCmdStatus-&gt;xferLen   = EFM32_MIN(<a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a>,
<a name="l00569"></a>00569                                         cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#af731f84bb4dd977080536bc124573bc5" title="Number of sense data bytes requested.">AllocationLength</a>);
<a name="l00570"></a>00570       pSenseData = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;NoSenseData;
<a name="l00571"></a>00571     }
<a name="l00572"></a>00572     <span class="keywordflow">break</span>;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga5f964a9cdf8ee464d1250534d85b67be" title="SCSI Read Capacity command opcode.">SCSI_READCAPACITY</a>:
<a name="l00575"></a>00575     cbRC = (<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     if ((cbRC-&gt;<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html#a0c5c6644819e22145dddcebc72042fa0" title="Partial medium indicator.">Pmi</a> == 0) &amp;&amp; (cbRC-&gt;<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html#a68cd5734a4019cd89f9880c7ea74b95b" title="Logical Block (sector) Address.">Lba</a> == 0))
<a name="l00578"></a>00578     {
<a name="l00579"></a>00579       ReadCapData.LogicalBlockAddress = __REV(MSDDMEDIA_GetSectorCount() - 1);
<a name="l00580"></a>00580       ReadCapData.LogicalBlockLength  = __REV(512);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00583"></a>00583       pCmdStatus-&gt;direction = DIR_DATA_IN;
<a name="l00584"></a>00584       pCmdStatus-&gt;pData     = (uint8_t*) &amp;ReadCapData;
<a name="l00585"></a>00585       pCmdStatus-&gt;xferLen   = <a class="code" href="group__Msd.html#gab6ed4755185c4e6d8d0de6f8dd021e8c" title="SCSI Read Capacity response data length.">SCSI_READCAPACITYDATA_LEN</a>;
<a name="l00586"></a>00586     }
<a name="l00587"></a>00587     <span class="keywordflow">break</span>;
<a name="l00588"></a>00588 
<a name="l00589"></a>00589   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4f9d424a949ee51924aa88f283afb085" title="SCSI Read (10) command opcode.">SCSI_READ10</a>:
<a name="l00590"></a>00590     cbR10 = (<a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592     pCmdStatus-&gt;direction = DIR_DATA_IN;
<a name="l00593"></a>00593     pCmdStatus-&gt;valid     = MSDDMEDIA_CheckAccess(pCmdStatus,
<a name="l00594"></a>00594                                                   __REV(cbR10-&gt;<a class="code" href="structMSDSCSI__Read10__TypeDef.html#a0f7d380926a76054cfc9f1ba47e606b0" title="Logical Block (sector) Address.">Lba</a>),
<a name="l00595"></a>00595                                                   __REV16(cbR10-&gt;<a class="code" href="structMSDSCSI__Read10__TypeDef.html#ac761573476109ed41d9ae45932d3fcf4" title="Number of blocks (sectors) to transfer.">TransferLength</a>));
<a name="l00596"></a>00596     <span class="keywordflow">break</span>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4a9efd10e4c1670e2c3546f937e9cb34" title="SCSI Write (10) command opcode.">SCSI_WRITE10</a>:
<a name="l00599"></a>00599     cbW10 = (<a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601     pCmdStatus-&gt;direction = DIR_DATA_OUT;
<a name="l00602"></a>00602     pCmdStatus-&gt;valid     = MSDDMEDIA_CheckAccess(pCmdStatus,
<a name="l00603"></a>00603                                                   __REV(cbW10-&gt;<a class="code" href="structMSDSCSI__Write10__TypeDef.html#a8e61a32441fc28c57dbc04a9962d0386" title="Logical Block (sector) Address.">Lba</a>),
<a name="l00604"></a>00604                                                   __REV16(cbW10-&gt;<a class="code" href="structMSDSCSI__Write10__TypeDef.html#a5473a605c45f7cda62e548f54d7091dd" title="Number of blocks (sectors) to transfer.">TransferLength</a>));
<a name="l00605"></a>00605     <span class="keywordflow">break</span>;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#gac15197fa8bd507ec529006c64f8437eb" title="SCSI Test Unit Ready command opcode.">SCSI_TESTUNIT_READY</a>:
<a name="l00608"></a>00608     pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00609"></a>00609     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00610"></a>00610     pCmdStatus-&gt;xferLen   = 0;
<a name="l00611"></a>00611     <span class="keywordflow">break</span>;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga732b33c6fded33c1e25db28a34f38315" title="SCSI Start Stop Unit command opcode.">SCSI_STARTSTOP_UNIT</a>:
<a name="l00614"></a>00614     pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00615"></a>00615     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00616"></a>00616     pCmdStatus-&gt;xferLen   = 0;
<a name="l00617"></a>00617     pCmdStatus-&gt;xferType  = XFER_INDIRECT;
<a name="l00618"></a>00618     <span class="keywordflow">break</span>;
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <span class="keywordflow">if</span> (!pCmdStatus-&gt;valid)
<a name="l00622"></a>00622   {
<a name="l00623"></a>00623     pCmdStatus-&gt;xferLen   = 0;
<a name="l00624"></a>00624     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00625"></a>00625     pSenseData            = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;IllegalSenseData;
<a name="l00626"></a>00626   }
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="comment">/**************************************************************************/</span>
<a name="l00633"></a>00633 __STATIC_INLINE <span class="keywordtype">void</span> SendCsw(<span class="keywordtype">void</span>)
<a name="l00634"></a>00634 {
<a name="l00635"></a>00635   <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00636"></a>00636     GPIO_PinOutToggle((GPIO_Port_TypeDef)ledPort, ledPin);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   USBD_Write(BULK_IN, (<span class="keywordtype">void</span>*) &amp;csw, CSW_LEN, NULL);
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="comment">/**************************************************************************/</span>
<a name="l00653"></a>00653 <span class="keyword">static</span> <span class="keywordtype">int</span> UsbSetupCmd(<span class="keyword">const</span> USB_Setup_TypeDef *setup)
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655   <span class="keywordtype">int</span>             retVal;
<a name="l00656"></a>00656   <span class="keyword">static</span> uint32_t tmp;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   retVal = USB_STATUS_REQ_UNHANDLED;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="comment">/* Check if it is MSD class command: &quot;Bulk-Only Mass Storage Reset&quot; */</span>
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   <span class="keywordflow">if</span> ((setup-&gt;Type == USB_SETUP_TYPE_CLASS) &amp;&amp;
<a name="l00663"></a>00663       (setup-&gt;Direction == USB_SETUP_DIR_OUT) &amp;&amp;
<a name="l00664"></a>00664       (setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE) &amp;&amp;
<a name="l00665"></a>00665       (setup-&gt;bRequest == USB_MSD_BOTRESET) &amp;&amp;
<a name="l00666"></a>00666       (setup-&gt;wValue == 0) &amp;&amp;
<a name="l00667"></a>00667       (setup-&gt;wIndex == 0) &amp;&amp;
<a name="l00668"></a>00668       (setup-&gt;wLength == 0))
<a name="l00669"></a>00669   {
<a name="l00670"></a>00670     <span class="keywordflow">if</span> (msdState == MSDD_WAITFOR_RECOVERY)
<a name="l00671"></a>00671     {
<a name="l00672"></a>00672       msdState = MSDD_IDLE;
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674     retVal = USB_STATUS_OK;
<a name="l00675"></a>00675   }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 
<a name="l00678"></a>00678   <span class="comment">/* Check if it is MSD class command: &quot;Get Max LUN&quot; */</span>
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((setup-&gt;Type == USB_SETUP_TYPE_CLASS) &amp;&amp;
<a name="l00681"></a>00681            (setup-&gt;Direction == USB_SETUP_DIR_IN) &amp;&amp;
<a name="l00682"></a>00682            (setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE) &amp;&amp;
<a name="l00683"></a>00683            (setup-&gt;bRequest == USB_MSD_GETMAXLUN) &amp;&amp;
<a name="l00684"></a>00684            (setup-&gt;wValue == 0) &amp;&amp;
<a name="l00685"></a>00685            (setup-&gt;wIndex == 0) &amp;&amp;
<a name="l00686"></a>00686            (setup-&gt;wLength == 1))
<a name="l00687"></a>00687   {
<a name="l00688"></a>00688     <span class="comment">/* Only one LUN (i.e. no support for multiple LUN&#39;s). Reply &quot;0&quot;. */</span>
<a name="l00689"></a>00689     tmp    = 0;
<a name="l00690"></a>00690     retVal = USBD_Write(0, (<span class="keywordtype">void</span>*) &amp;tmp, 1, NULL);
<a name="l00691"></a>00691   }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="comment">/* Check if it is a standard CLEAR_FEATURE endpoint command */</span>
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((setup-&gt;Type == USB_SETUP_TYPE_STANDARD) &amp;&amp;
<a name="l00697"></a>00697            (setup-&gt;Direction == USB_SETUP_DIR_OUT) &amp;&amp;
<a name="l00698"></a>00698            (setup-&gt;Recipient == USB_SETUP_RECIPIENT_ENDPOINT) &amp;&amp;
<a name="l00699"></a>00699            (setup-&gt;bRequest == CLEAR_FEATURE) &amp;&amp;
<a name="l00700"></a>00700            (setup-&gt;wValue == USB_FEATURE_ENDPOINT_HALT) &amp;&amp;
<a name="l00701"></a>00701            (setup-&gt;wLength == 0))
<a name="l00702"></a>00702   {
<a name="l00703"></a>00703     <span class="keywordflow">if</span> (((setup-&gt;wIndex &amp; 0xFF) == BULK_OUT) ||
<a name="l00704"></a>00704         ((setup-&gt;wIndex &amp; 0xFF) == BULK_IN))
<a name="l00705"></a>00705     {
<a name="l00706"></a>00706       retVal = USB_STATUS_OK;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708       <span class="comment">/* Dont unstall ep&#39;s when waiting for reset recovery */</span>
<a name="l00709"></a>00709       <span class="keywordflow">if</span> (msdState != MSDD_WAITFOR_RECOVERY)
<a name="l00710"></a>00710       {
<a name="l00711"></a>00711         retVal = USBD_UnStallEp(setup-&gt;wIndex &amp; 0xFF);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713         <span class="keywordflow">if</span> ((setup-&gt;wIndex &amp; 0xFF) == BULK_IN)
<a name="l00714"></a>00714         {
<a name="l00715"></a>00715           <span class="keywordflow">if</span> (msdState == MSDD_WAIT_FOR_INUNSTALLED)
<a name="l00716"></a>00716           {
<a name="l00717"></a>00717             SendCsw();
<a name="l00718"></a>00718             EnableNextCbw();
<a name="l00719"></a>00719             msdState = MSDD_WAITFOR_CBW;
<a name="l00720"></a>00720           }
<a name="l00721"></a>00721         }
<a name="l00722"></a>00722         <span class="keywordflow">else</span>
<a name="l00723"></a>00723         {
<a name="l00724"></a>00724           EnableNextCbw();
<a name="l00725"></a>00725           msdState = MSDD_WAITFOR_CBW;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727       }
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729   }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   <span class="keywordflow">return</span> retVal;
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734 <span class="comment">/**************************************************************************/</span>
<a name="l00744"></a>00744 <span class="keyword">static</span> <span class="keywordtype">void</span> UsbStateChangeEvent(USBD_State_TypeDef oldState,
<a name="l00745"></a>00745                                 USBD_State_TypeDef newState)
<a name="l00746"></a>00746 {
<a name="l00747"></a>00747   <span class="keywordflow">if</span> (newState == USBD_STATE_CONFIGURED)
<a name="l00748"></a>00748   {
<a name="l00749"></a>00749     <span class="comment">/* We have been configured, start MSD functionality ! */</span>
<a name="l00750"></a>00750     EnableNextCbw();
<a name="l00751"></a>00751     msdState = MSDD_WAITFOR_CBW;
<a name="l00752"></a>00752   }
<a name="l00753"></a>00753 
<a name="l00754"></a>00754   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((oldState == USBD_STATE_CONFIGURED) &amp;&amp;
<a name="l00755"></a>00755            (newState != USBD_STATE_SUSPENDED))
<a name="l00756"></a>00756   {
<a name="l00757"></a>00757     <span class="comment">/* We have been de-configured */</span>
<a name="l00758"></a>00758     msdState = MSDD_IDLE;
<a name="l00759"></a>00759   }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newState == USBD_STATE_SUSPENDED)
<a name="l00762"></a>00762   {
<a name="l00763"></a>00763     <span class="comment">/* We have been suspended.                     */</span>
<a name="l00764"></a>00764     msdState = MSDD_IDLE;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766     <span class="comment">/* Reduce current consumption to below 2.5 mA. */</span>
<a name="l00767"></a>00767   }
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="comment">/**************************************************************************/</span>
<a name="l00784"></a>00784 <span class="keyword">static</span> <span class="keywordtype">void</span> UsbXferBotData(uint8_t *data, uint32_t len,
<a name="l00785"></a>00785                            USB_XferCompleteCb_TypeDef cb)
<a name="l00786"></a>00786 {
<a name="l00787"></a>00787   <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00788"></a>00788   {
<a name="l00789"></a>00789     USBD_Write(BULK_IN, data, len, cb);
<a name="l00790"></a>00790   }
<a name="l00791"></a>00791   <span class="keywordflow">else</span>
<a name="l00792"></a>00792   {
<a name="l00793"></a>00793     USBD_Read(BULK_OUT, data, len, cb);
<a name="l00794"></a>00794   }
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="comment">/**************************************************************************/</span>
<a name="l00805"></a>00805 <span class="keyword">static</span> <span class="keywordtype">void</span> XferBotData(uint32_t length)
<a name="l00806"></a>00806 {
<a name="l00807"></a>00807   pCmdStatus-&gt;xferLen   = length;
<a name="l00808"></a>00808   pCsw-&gt;dCSWDataResidue = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="keywordflow">if</span> (pCmdStatus-&gt;xferType == XFER_INDIRECT)
<a name="l00811"></a>00811   {
<a name="l00812"></a>00812     <span class="comment">/* Access media in &quot;background&quot; polling loop, i.e. in MSDD_Handler() */</span>
<a name="l00813"></a>00813     savedState = msdState;
<a name="l00814"></a>00814     msdState   = MSDD_ACCESS_INDIRECT;
<a name="l00815"></a>00815   }
<a name="l00816"></a>00816   <span class="keywordflow">else</span>
<a name="l00817"></a>00817   {
<a name="l00818"></a>00818     UsbXferBotData(pCmdStatus-&gt;pData,
<a name="l00819"></a>00819                    EFM32_MIN(length, pCmdStatus-&gt;maxBurst),
<a name="l00820"></a>00820                    XferBotDataCallback);
<a name="l00821"></a>00821   }
<a name="l00822"></a>00822 }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 <span class="comment">/**************************************************************************/</span>
<a name="l00843"></a>00843 <span class="keyword">static</span> <span class="keywordtype">int</span> XferBotDataCallback(USB_Status_TypeDef status,
<a name="l00844"></a>00844                                uint32_t xferred, uint32_t remaining)
<a name="l00845"></a>00845 {
<a name="l00846"></a>00846   (void) status;
<a name="l00847"></a>00847   (void) remaining;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   pCmdStatus-&gt;xferLen   -= xferred;
<a name="l00850"></a>00850   pCsw-&gt;dCSWDataResidue -= xferred;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00853"></a>00853   {
<a name="l00854"></a>00854     pCmdStatus-&gt;pData += xferred;
<a name="l00855"></a>00855     UsbXferBotData(pCmdStatus-&gt;pData,
<a name="l00856"></a>00856                    EFM32_MIN(pCmdStatus-&gt;xferLen, pCmdStatus-&gt;maxBurst),
<a name="l00857"></a>00857                    XferBotDataCallback);
<a name="l00858"></a>00858   }
<a name="l00859"></a>00859   <span class="keywordflow">else</span>
<a name="l00860"></a>00860   {
<a name="l00861"></a>00861     <span class="keywordflow">if</span> (msdState == MSDD_SEND_CSW)
<a name="l00862"></a>00862     {
<a name="l00863"></a>00863       SendCsw();
<a name="l00864"></a>00864       EnableNextCbw();
<a name="l00865"></a>00865       msdState = MSDD_WAITFOR_CBW;
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867 
<a name="l00868"></a>00868     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msdState == MSDD_STALL_IN)
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870       USBD_StallEp(BULK_IN);
<a name="l00871"></a>00871       msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00872"></a>00872     }
<a name="l00873"></a>00873   }
<a name="l00874"></a>00874 
<a name="l00875"></a>00875   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00876"></a>00876 }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 <span class="comment">/**************************************************************************/</span>
<a name="l00895"></a>00895 <span class="keyword">static</span> <span class="keywordtype">int</span> XferBotDataIndirectCallback(USB_Status_TypeDef status,
<a name="l00896"></a>00896                                        uint32_t xferred, uint32_t remaining)
<a name="l00897"></a>00897 {
<a name="l00898"></a>00898   (void) status;
<a name="l00899"></a>00899   (void) remaining;
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   pCmdStatus-&gt;xferLen   -= xferred;
<a name="l00902"></a>00902   pCsw-&gt;dCSWDataResidue -= xferred;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00905"></a>00905   {
<a name="l00906"></a>00906     pCmdStatus-&gt;lba += xferred / 512;
<a name="l00907"></a>00907     msdState         = MSDD_ACCESS_INDIRECT;
<a name="l00908"></a>00908   }
<a name="l00909"></a>00909   <span class="keywordflow">else</span>
<a name="l00910"></a>00910   {
<a name="l00911"></a>00911     msdState = MSDD_WRITE_INDIRECT;
<a name="l00912"></a>00912   }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Fri Nov 9 16:47:43 2012</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
